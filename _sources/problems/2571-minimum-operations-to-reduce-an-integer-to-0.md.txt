# 2571-minimum-operations-to-reduce-an-integer-to-0


Try it on <a href='https://leetcode.com/problems/2571-minimum-operations-to-reduce-an-integer-to-0'>leetcode</a>

## Description
<div class="description">
<p>You are given a positive integer <code>n</code>, you can do the following operation <strong>any</strong> number of times:</p>

<ul>
	<li>Add or subtract a <strong>power</strong> of <code>2</code> from <code>n</code>.</li>
</ul>

<p>Return <em>the <strong>minimum</strong> number of operations to make </em><code>n</code><em> equal to </em><code>0</code>.</p>

<p>A number <code>x</code> is power of <code>2</code> if <code>x == 2<sup>i</sup></code>&nbsp;where <code>i &gt;= 0</code><em>.</em></p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> n = 39
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations:
- Add 2<sup>0</sup> = 1 to n, so now n = 40.
- Subtract 2<sup>3</sup> = 8 from n, so now n = 32.
- Subtract 2<sup>5</sup> = 32 from n, so now n = 0.
It can be shown that 3 is the minimum number of operations we need to make n equal to 0.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> n = 54
<strong>Output:</strong> 3
<strong>Explanation:</strong> We can do the following operations:
- Add 2<sup>1</sup> = 2 to n, so now n = 56.
- Add 2<sup>3</sup> = 8 to n, so now n = 64.
- Subtract 2<sup>6</sup> = 64 from n, so now n = 0.
So the minimum number of operations is 3.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
</ul>

</div>

## Solution(Python)
```Python
class Solution:
    def minOperations(self, n: int) -> int:
        return self.minOptimnalOperations(n)
    def minOptimnalOperations(self, n: int) -> int:
        # Initialize result counter and consecutive 1-bits counter
        operations = 0
        consecutive_ones = 0
      
        # Process each bit of n from right to left
        while n > 0:
            # Check if the current least significant bit is 1
            if n & 1:
                # Increment counter for consecutive 1-bits
                consecutive_ones += 1
            elif consecutive_ones > 0:
                # We hit a 0 after seeing 1s, process the group of 1s
                operations += 1
                # Reset counter: if we had exactly one 1, start fresh
                # Otherwise, carry over 1 (for cases like 11 -> 100)
                consecutive_ones = 0 if consecutive_ones == 1 else 1
          
            # Right shift to check the next bit
            n >>= 1
      
        # Handle any remaining consecutive 1-bits after the loop
        if consecutive_ones == 1:
            # Single 1-bit requires one operation
            operations += 1
        elif consecutive_ones > 1:
            # Multiple consecutive 1-bits require two operations
            operations += 2
      
        return operations

    def mindpOperations(self, n: int) -> int:
        @lru_cache(maxsize=None)
        def dp(x):
            if x == 0:
                return 0
            if x == 1:
                return 1
            if x % 2 == 0:
                return dp(x // 2)
            else:
                return 1 + min(dp(x // 2), dp((x + 1) // 2))
        
        return dp(n)


```