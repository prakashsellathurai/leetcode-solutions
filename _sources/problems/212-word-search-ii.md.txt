# 212-word-search-ii


Try it on <a href='https://leetcode.com/problems/212-word-search-ii'>leetcode</a>

## Description
<div class="description">
<div><p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>

<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" style="width: 322px; height: 322px;">
<pre><strong>Input:</strong> board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
<strong>Output:</strong> ["eat","oath"]
</pre>

<p><strong>Example 2:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" style="width: 162px; height: 162px;">
<pre><strong>Input:</strong> board = [["a","b"],["c","d"]], words = ["abcb"]
<strong>Output:</strong> []
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>m == board.length</code></li>
	<li><code>n == board[i].length</code></li>
	<li><code>1 &lt;= m, n &lt;= 12</code></li>
	<li><code>board[i][j]</code> is a lowercase English letter.</li>
	<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>
	<li><code>1 &lt;= words[i].length &lt;= 10</code></li>
	<li><code>words[i]</code> consists of lowercase English letters.</li>
	<li>All the strings of <code>words</code> are unique.</li>
</ul>
</div>
</div>

## Solution(Python)
```Python
class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word):
        node = self.root
        for w in word:
            if w not in node:
                node[w] = {}
            node = node[w]
        node['#'] = word


class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        trie = Trie()
        for word in words:
            trie.insert(word)

        m, n = len(board), len(board[0])
        dirs = [[-1, 0], [1, 0], [0, 1], [0, -1]]
        res = []

        def dfs(root, i, j):
            c = board[i][j]
            if c not in root:
                return
            child = root[c]
            word = child.pop('#', None)
            if word:
                res.append(word)
            if not child:
                root.pop(c)

            board[i][j] = '#'
            for dx, dy in dirs:
                x = i + dx
                y = j + dy
                if 0 <= x < m and 0 <= y < n:
                    dfs(child, x, y)
            board[i][j] = c

        for i in range(m):
            for j in range(n):
                dfs(trie.root, i, j)

        return res
```