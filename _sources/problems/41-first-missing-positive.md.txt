# 41-first-missing-positive


Try it on <a href='https://leetcode.com/problems/41-first-missing-positive'>leetcode</a>

## Description
<div class="description">
<div><p>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p>

<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>
<pre><strong>Input:</strong> nums = [1,2,0]
<strong>Output:</strong> 3
</pre><p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong> nums = [3,4,-1,1]
<strong>Output:</strong> 2
</pre><p><strong>Example 3:</strong></p>
<pre><strong>Input:</strong> nums = [7,8,9,11,12]
<strong>Output:</strong> 1
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>
	<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>
</ul>
</div>
</div>

## Solution(Python)
```Python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        i = 0
        n = len(nums)
        
        def segregate(arr, n):
            j = 0
            for i in range(n):
                if (arr[i] <= 0):
                    arr[i], arr[j] = arr[j], arr[i]
                    j += 1 # increment count of non-positive integers
            return j
        shift = segregate(nums, n)
        nums = nums[shift:]
        size = n-shift
        for i in range(size):
            if (abs(nums[i]) - 1 < size and nums[abs(nums[i]) - 1] > 0):
                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1]

        # Return the first index value at which is positive
        for i in range(size):
            if (nums[i] > 0):

                # 1 is added because indexes start from 0
                return i + 1
        return size + 1
```