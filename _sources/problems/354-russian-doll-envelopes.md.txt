# 354-russian-doll-envelopes


Try it on <a href='https://leetcode.com/problems/354-russian-doll-envelopes'>leetcode</a>

## Description
<div class="description">
<div><p>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> represents the width and the height of an envelope.</p>

<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.</p>

<p>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.</p>

<p><strong>Note:</strong> You cannot rotate an envelope.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre><strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).
</pre>

<p><strong>Example 2:</strong></p>

<pre><strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]
<strong>Output:</strong> 1
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>
	<li><code>envelopes[i].length == 2</code></li>
	<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>
</ul>
</div>
</div>

## Solution(Python)
```Python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        return self.binarysearch(envelopes)
    
    # Time Complexity: O(2^n)
    # Space Complexity: O(n)  
    def bruteforce(self, envelopes: List[List[int]]) -> int:
        envelopes.sort()
        n = len(envelopes)
        def dfs(i):
            res = 1
            for j in range(i):
                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:
                    res = max(res,1+dfs(j))
            return res
        
        maxlen = 0
        for i in range(n):
            maxlen = max(maxlen, dfs(i))
        return maxlen
        
    # Time Complexity: O(n^2)
    # Space Complexity: O(n)
    # H[j] = i<j{max(H(i))}+1
    def dynamicprogramming(self, envelopes: List[List[int]]) -> int:
        envelopes.sort()
        
        n = len(envelopes)
        dp = [1]*n
        for i in range(n):
            for j in range(i):
                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:
                    dp[i] = max(dp[i],dp[j]+1)

        return max(dp)
    
    # Time Complexity: O(n^2)
    # Space Complexity: O(n)
    def sortingwithmemoize(self, envelopes: List[List[int]]) -> int:
        envelopes.sort()
        n = len(envelopes)
        dp = [-1]*n
        
        def dfs(i):
            if dp[i] != -1:
                return dp[i]
            res = 1
            for j in range(i):
                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:
                    res = max(res,1+dfs(j))
            dp[i] = res
            return dp[i]
        
        maxlen = 0
        for i in range(n):
            maxlen = max(maxlen, dfs(i))
        return maxlen
    
    # Time Complexity: O(nlogn)
    # Space Complexity: O(n)
    def binarysearch(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key=lambda x:(x[0],-x[1]))
        dp = []
        for envelope in envelopes:
            pos = bisect.bisect_left(dp,envelope[1])
            if pos == len(dp):
                dp.append(envelope[1])
            else:
                dp[pos] = envelope[1]
                
        return len(dp)
        
        
```