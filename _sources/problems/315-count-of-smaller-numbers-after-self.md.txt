# 315-count-of-smaller-numbers-after-self


Try it on <a href='https://leetcode.com/problems/315-count-of-smaller-numbers-after-self'>leetcode</a>

## Description
<div class="description">
<div><p>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>

<p>&nbsp;</p>
<p><strong>Example 1:</strong></p>

<pre><strong>Input:</strong> nums = [5,2,6,1]
<strong>Output:</strong> [2,1,1,0]
<strong>Explanation:</strong>
To the right of 5 there are <b>2</b> smaller elements (2 and 1).
To the right of 2 there is only <b>1</b> smaller element (1).
To the right of 6 there is <b>1</b> smaller element (1).
To the right of 1 there is <b>0</b> smaller element.
</pre>

<p><strong>Example 2:</strong></p>

<pre><strong>Input:</strong> nums = [-1]
<strong>Output:</strong> [0]
</pre>

<p><strong>Example 3:</strong></p>

<pre><strong>Input:</strong> nums = [-1,-1]
<strong>Output:</strong> [0,0]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>
</ul>
</div>
</div>

## Solution(Python)
```Python
class SelfBST:
    def __init__(self, arr, n):
        self.n = n
        self.cntArray = [0]*n
        
    
    def cntArr(self):
        return self.cntArray
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        return self.selfBalanceBst(nums)
    
    # Time Complexity: O(n^2)
    # Space Complexity: O(n)
    def naive(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res  = [0]*n
        for i in range(n):
            for j in range(i+1, n):
                if nums[j] < nums[i]:
                    res[i] +=1 
        return res
    
    # Time Complexity: O(nlogn)
    # Space Complexity: O(n)
    def selfBalanceBst(self, nums: List[int]) -> List[int]:
        rank, N, res = {val: i + 1 for i, val in enumerate(sorted(nums))}, len(nums), []
        BITree = [0] * (N + 1)

        def update(i):
            while i <= N:
                BITree[i] += 1
                i += (i & -i)

        def getSum(i):
            s = 0
            while i:
                s += BITree[i]
                i -= (i & -i)
            return s

        for x in reversed(nums):
            res += getSum(rank[x] - 1),
            update(rank[x])
        return res[::-1]
```