# 0003-longest-substring-without-repeating-characters


Try it on <a href='https://leetcode.com/problems/0003-longest-substring-without-repeating-characters'>leetcode</a>

## Description
<div class="description">
<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword="substring-nonempty"><strong>substring</strong></span> without duplicate characters.</p>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;abcabcbb&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3. Note that <code>&quot;bca&quot;</code> and <code>&quot;cab&quot;</code> are also correct answers.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;bbbbb&quot;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> s = &quot;pwwkew&quot;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.
Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>
</ul>

</div>

## Solution(Python)
```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        return self.optimal(s)
        
    # Time Complexity: O(n^3)
    # Space Complexity: O(n)
    def bruteforce(self, s: str) -> int:
        n = len(s)
        long_sub_len = 0
        
        def isUnique(st):
            return len(st) == len(set(st))
        
        for i in range(n):
            for j in range(i,n):
                if isUnique(s[i:j]):
                    cur_len = j-i
                    if cur_len > long_sub_len:
                        long_sub_len = cur_len
        return long_sub_len
    
    # Time Complexity: O(n)
    # Space Complexity: O(min(m,n))
    def better(self, s: str) -> int:
        n = len(s)
        left = right = 0
        hashmap = defaultdict(lambda : 0)
        res = 0
        
        while right < n:
            hashmap[s[right]] += 1
            
            while hashmap[s[right]]  > 1:
                hashmap[s[left]] -= 1
                left += 1
                
            cur_width = right - left + 1 
            
            if cur_width > res:
                res = cur_width
            
            right += 1
            
        return res
    
    # Time Complexity: O(n)
    # Space Complexity: O(m)
    def optimal(self, s: str) -> int:
        seen = {}
        start = 0
        res = 0
        for end,c in enumerate(s):
            if c in seen:
                start = max(start,seen[c]+1)
            seen[c] = end
            res = max(res ,end-start+1)
        return res
```