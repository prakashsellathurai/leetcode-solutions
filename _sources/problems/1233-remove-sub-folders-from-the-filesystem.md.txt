# 1233-remove-sub-folders-from-the-filesystem


Try it on <a href='https://leetcode.com/problems/1233-remove-sub-folders-from-the-filesystem'>leetcode</a>

## Description
<div class="description">
<p>Given a list of folders <code>folder</code>, return <em>the folders after removing all <strong>sub-folders</strong> in those folders</em>. You may return the answer in <strong>any order</strong>.</p>

<p>If a <code>folder[i]</code> is located within another <code>folder[j]</code>, it is called a <strong>sub-folder</strong> of it. A sub-folder of <code>folder[j]</code> must start with <code>folder[j]</code>, followed by a <code>&quot;/&quot;</code>. For example, <code>&quot;/a/b&quot;</code> is a sub-folder of <code>&quot;/a&quot;</code>, but <code>&quot;/b&quot;</code> is not a sub-folder of <code>&quot;/a/b/c&quot;</code>.</p>

<p>The format of a path is one or more concatenated strings of the form: <code>&#39;/&#39;</code> followed by one or more lowercase English letters.</p>

<ul>
	<li>For example, <code>&quot;/leetcode&quot;</code> and <code>&quot;/leetcode/problems&quot;</code> are valid paths while an empty string and <code>&quot;/&quot;</code> are not.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a&quot;,&quot;/a/b&quot;,&quot;/c/d&quot;,&quot;/c/d/e&quot;,&quot;/c/f&quot;]
<strong>Output:</strong> [&quot;/a&quot;,&quot;/c/d&quot;,&quot;/c/f&quot;]
<strong>Explanation:</strong> Folders &quot;/a/b&quot; is a subfolder of &quot;/a&quot; and &quot;/c/d/e&quot; is inside of folder &quot;/c/d&quot; in our filesystem.
</pre>

<p><strong class="example">Example 2:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a&quot;,&quot;/a/b/c&quot;,&quot;/a/b/d&quot;]
<strong>Output:</strong> [&quot;/a&quot;]
<strong>Explanation:</strong> Folders &quot;/a/b/c&quot; and &quot;/a/b/d&quot; will be removed because they are subfolders of &quot;/a&quot;.
</pre>

<p><strong class="example">Example 3:</strong></p>

<pre>
<strong>Input:</strong> folder = [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]
<strong>Output:</strong> [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= folder.length &lt;= 4 * 10<sup>4</sup></code></li>
	<li><code>2 &lt;= folder[i].length &lt;= 100</code></li>
	<li><code>folder[i]</code> contains only lowercase letters and <code>&#39;/&#39;</code>.</li>
	<li><code>folder[i]</code> always starts with the character <code>&#39;/&#39;</code>.</li>
	<li>Each folder name is <strong>unique</strong>.</li>
</ul>

</div>

## Solution(Python)
```Python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEndOfFolder = False

class Solution:
    def __init__(self):
        self.root = TrieNode()

    def removeSubfolders(self, folder: List[str]) -> List[str]:
        return self.trie_(folder)
    

    # Time Complexity: O(N*L^2)
    # Space Complexity: O(N*L)
    def set_(self, folder: List[str]) -> List[str]:
        folderSet = set(folder)
        result  = []
        for folder in folder:
            isSubFolder = False
            prefix = folder
            while not prefix == "":
                pos = prefix.rfind("/")
                if not pos:
                    break
                prefix = prefix[0:pos]
                if prefix in folderSet:
                    isSubFolder = True
                    break
            if not isSubFolder:
                result.append(folder)
                
        return result

    
    # Time Complexity: O(N*L*logN)
    # Space Complexity: O(N*L)
    def sort_(self, folder: List[str]) -> List[str]:   
        folder.sort()
        result  = []
        for f in  folder:
            if len(result) == 0:
                result.append(f)
                continue
            lastfolder = result[-1]
            lastfolder+="/"
            if not f.startswith(lastfolder):
                result.append(f)
        return result
        
    # Time Complexity: O(N*L)
    # Space Complexity: O(N*L)
    def trie_(self, folder: List[str]) -> List[str]:   
        for path in folder:
            cur_node = self.root
            folders = path.split("/")
            for foldername in folders:
                if foldername == "":
                    continue
                if foldername not in cur_node.children:
                    cur_node.children[foldername] = TrieNode()
                cur_node = cur_node.children[foldername]
            cur_node.isEndOfFolder = True
        
        result = []

        for path in folder:
            current_node = self.root
            folders = path.split("/")
            is_subfolder = False

            for i, folder_name in enumerate(folders):
                if folder_name == "":
                    continue
                next_node = current_node.children[folder_name]
                # Check if the current folder path is a subfolder of an existing folder
                if next_node.isEndOfFolder and i != len(folders) - 1:
                    is_subfolder = True
                    break  # Found a subfolder
                current_node = next_node

            # If not a subfolder, add to the result
            if not is_subfolder:
                result.append(path)
        return result

        
```